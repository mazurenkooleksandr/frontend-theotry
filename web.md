<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Які HTTP-методи та статуси знаєте?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>HTTP-методи:<br>
- GET: Використовується для отримання даних з сервера. Параметри передаються через URL.<br>
- POST: Використовується для відправлення даних на сервер для створення нового ресурсу. Параметри передаються у тілі запиту.<br>
- PUT: Використовується для оновлення існуючого ресурсу або створення нового, якщо його не існує. Параметри передаються у тілі запиту.<br>
- DELETE: Використовується для видалення ресурсу на сервері. Параметри можуть передаватися у тілі запиту або через URL.<br>
- PATCH: Використовується для часткового оновлення ресурсу на сервері. Параметри передаються у тілі запиту.<br>
- HEAD: Аналогічний методу GET, але повертає тільки заголовки без тіла відповіді. Використовується для отримання метаінформації про ресурс.<br>
- OPTIONS: Використовується для отримання інформації про можливі методи та параметри для ресурсу.<br>
- TRACE: Використовується для отримання діагностичної інформації від сервера. Рідко використовується у виробничих системах через потенційні безпекові ризики.<br>
    HTTP-статуси:<br>
    - 1xx (Informational):<br>
    100 Continue<br>
    101 Switching Protocols<br>
    - 2xx (Successful):<br>
    200 OK<br>
    201 Created<br>
    204 No Content<br>
    - 3xx (Redirection):<br>
    301 Moved Permanently<br>
    302 Found (Moved Temporarily)<br>
    304 Not Modified<br>
    - 4xx (Client Error):<br>
    400 Bad Request<br>
    401 Unauthorized<br>
    403 Forbidden<br>
    404 Not Found<br>
    405 Method Not Allowed<br>
    - 5xx (Server Error):<br>
    500 Internal Server Error<br>
    501 Not Implemented<br>
    503 Service Unavailable<br>
    Ці статуси і методи використовуються для взаємодії між клієнтом та сервером у протоколі HTTP. Клієнтські програми використовують ці методи для виконання дій на сервері, а сервер відправляє статус відповіді, щоб повідомити про результат виконання запиту.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що ви знаєте про Core Web Vitals?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Core Web Vitals - це набір ключових показників ефективності веб-сторінок, які визначають важливі аспекти взаємодії користувача, відображення контенту та загальної швидкості завантаження веб-сайтів. Цей набір показників визначений Google і використовується для оцінки користувальницького досвіду на веб-сайтах. <br>
    - Largest Contentful Paint (LCP): Це вимірює час, який потрібен для відображення найбільшого елемента контенту на сторінці (наприклад, зображення або блок тексту).<br>
    - First Input Delay (FID): Визначає час, який користувач повинен чекати, перш ніж здійснити перший взаємодію (наприклад, клік або тап), після повного завантаження сторінки.<br>
    - Cumulative Layout Shift (CLS): Вимірює непередбачувані зсуви елементів на сторінці під час її завантаження, що може призводити до неприємного взаємодії користувача.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Які формати картинок знаєте, чим вони відрізняються?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>JPEG - це растровий формат, який використовується для зберігання фотографій та інших зображень з високою роздільною здатністю. JPEG є відносно невеликим форматом, але він може втрачати якість при стисканні.<br>
PNG - це растровий формат, який використовується для зберігання зображень з високою роздільною здатністю, які не повинні втрачати якість при стисканні. PNG є більшим форматом, ніж JPEG, але він забезпечує кращу якість зображення.<br>
GIF - це растровий формат, який використовується для зберігання анімованих зображень. GIF є відносно невеликим форматом, але він може підтримувати лише 256 кольорів.<br>
WebP - це растровий формат зображень, розроблений Google спеціально для веб-сайтів. Може стискати зображення до вдвічі меншого розміру порівняно з JPEG, не втрачаючи значної якості. Це робить його ідеальним для веб-сайтів, де швидкість завантаження має важливе значення.<br>
SVG - це векторний формат, який використовується для зберігання зображень, які можуть масштабуватися до будь-якого розміру без втрати якості. SVG є більшим форматом, ніж JPEG або PNG, але він забезпечує кращу якість зображення при масштабуванні.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке DOM?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>DOM (Document Object Model) - це програмний інтерфейс, який представляє структуру документа веб-сторінки у вигляді дерева об'єктів. DOM надає структурований спосіб доступу до та зміни вмісту, стилю і структури веб-документа.<br>
    Основні концепції DOM включають:<br>
    - Документ (Document): Представляє веб-сторінку або XML-документ. Всі об'єкти на сторінці, такі як елементи, атрибути та текст, є частинами DOM.<br>
    - Елементи (Elements): Це основні компоненти документа, такі як теги HTML (наприклад, div, p, a). Кожен елемент є об'єктом в DOM.<br>
    - Атрибути (Attributes): Характеристики елементів, які визначають їхню поведінку або вигляд. Наприклад, id, class, src - це атрибути.<br>
    - Вузли (Nodes): Всі об'єкти в DOM є вузлами, і їх класифікують як елементи, атрибути, текстові вузли і т.д.<br>
    - Текстові вузли (Text Nodes): Містять текстовий вміст елемента.<br>
    - Родичі та діти (Parent and Child): Елементи можуть мати батьківські та дочірні елементи. Батьківський елемент - це елемент, який оточує інший елемент, а дочірній елемент - це елемент, який знаходиться всередині іншого елемента.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Як JavaScript взаємодіє з DOM?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>JavaScript взаємодіє з DOM за допомогою набору методів і властивостей, які надаються об'єктом Document. Об'єкт Document представляє весь веб-документ, включаючи його структуру і вміст.<br>
    getElementById() - повертає об'єкт елемента HTML з заданим ідентифікатором.<br>
    getElementsByTagName() - повертає масив об'єктів елементів HTML з заданим ім'ям тега.<br>
    querySelector() - повертає перший об'єкт елемента HTML, який відповідає заданому селектору CSS.<br>
    querySelectorAll() - повертає масив об'єктів елементів HTML, які відповідають заданому селектору CSS.<br>
    setAttribute() - встановлює значення властивості елемента HTML.<br>
    removeAttribute() - видаляє властивість елемента HTML.<br>
    appendChild()` - додає елемент HTML до іншого елемента HTML.<br>
    removeChild()` - видаляє елемент HTML з іншого елемента HTML.
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке AJAX?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>AJAX означає Asynchronous JavaScript and XML. Це технологія, яка дозволяє веб-сторінкам оновлюватися динамічно без необхідності перезавантажувати всю сторінку. Це досягається за допомогою асинхронних запитів до сервера, які можна виконувати в фоновому режимі. 
    Основні компоненти технології AJAX:
    - XMLHttpRequest: Це об'єкт в JavaScript, який дозволяє виконувати HTTP-запити до сервера. Зазвичай використовується для отримання або відправки даних на сервер без перезавантаження сторінки.
    - Асинхронність: Запити виконуються асинхронно, що означає, що вони не блокують виконання інших операцій на сторінці. Коли запит виконується, сторінка може продовжувати реагувати на дії користувача.
    - Обмін даними у форматі XML або JSON: Оригінально технологія використовувалась для обміну даними у форматі XML, але зараз частіше використовується JSON, який є більш легким і зручним для обробки в JavaScript.
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке JSONP і як його використовують?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>JSONP (JSON with padding) - це розширення JSON, яке дозволяє виконувати асинхронні запити до сервера з інших доменів. Це досягається за рахунок того, що запит JSONP містить ім'я функції, яку повинен викликати сервер у відповідь на запит.<br>
    <pre>
    // Запит JSONP:
    script src="https://example.com/api.php?callback=myFunction" script
    // Функція обробки відповіді:
    function myFunction(data) {
      // Зробити щось із даними
    }
    </pre>
    У цьому прикладі запит JSONP виконується до сервера https://example.com/api.php. У запиті передається ім'я функції myFunction, яку повинен викликати сервер у відповідь на запит.<br>
    Функція myFunction() буде викликана сервером у відповідь на запит. Функція отримує як аргумент об'єкт JSON, який містить дані, які повернув сервер.<br>
    JSONP використовується в багатьох веб-додатках, включаючи:<br>
    - Погода<br>
    - Новини<br>
    - Соцмережі<br>
    JSONP має кілька переваг перед традиційними методами AJAX:<br>
    - Простота використання - JSONP простіше використовувати, ніж традиційні методи AJAX, які вимагають використання об'єкта XMLHttpRequest.<br>
    - Більша сумісність - JSONP підтримується більшістю веб-браузерів.<br>
    - JSONP також має деякі недоліки:<br>
    - Безпека - JSONP не є повністю безпечним, оскільки сервер може викликати будь-яку функцію в сценарії веб-сторінки.<br>
    - Обмежена функціональність - JSONP не підтримує всі можливості AJAX, такі як передача даних до сервера.
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке event bubbling та event capturing у контексті обробки подій у DOM? Як використовуєте ці концепції для ефективної обробки подій?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Event bubbling і event capturing - це два механізми поширення подій у DOM.<br>
    - Event bubbling - це процес, при якому подія поширюється від елемента, на якому вона відбулася, до його батьківських елементів. Буквально, це можна уявити як бульбашку, яка поширюється віднизу вверх.<br>
    - Event capturing - це процес, при якому подія поширюється від батьківських елементів елемента, на якому вона відбулася, до самого елемента. Буквально, це можна уявити як бульбашку, яка поширюється зверху вниз.<br>
    За замовчуванням, події поширюються за допомогою bubbling. Це означає, що функції обробки подій, які зареєстровані на батьківських елементах, будуть викликані до функцій обробки подій, які зареєстровані на самому елементі.<br>
    - Використовуйте event bubbling, коли потрібно обробити подію для всіх елементів у ієрархії DOM.<br>
    - Використовуйте event capturing, коли потрібно обробити подію до того, як вона буде оброблена функціями обробки подій, які зареєстровані на батьківських елементах.<br>
    - Використовуйте event.stopPropagation(), щоб зупинити поширення події.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке HTTP і HTTPS, яка між ними різниця?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>HTTP (Hypertext Transfer Protocol) і HTTPS (Hypertext Transfer Protocol Secure) є протоколами передачі даних в мережі Інтернет. Основна різниця між ними полягає в тому, що HTTPS використовує шифрування для забезпечення безпеки передачі даних, тоді як HTTP передає дані у відкритому текстовому форматі без шифрування.<br>
HTTP (Hypertext Transfer Protocol):<br>
- Незахищений протокол: HTTP передає дані у відкритому текстовому форматі, що робить його вразливим до перехоплення та зміни даних з боку недобросовісних користувачів.<br>
- Використовує порт 80: Зазвичай використовується порт 80 для передачі даних.<br>
- Не забезпечує конфіденційність даних: Інформація, яка передається через HTTP, не шифрується, тому вона може бути перехоплена і прочитана третіми сторонами.<br>
HTTPS (Hypertext Transfer Protocol Secure):<br>
- Захищений протокол: HTTPS використовує протокол TLS (Transport Layer Security) або його попередника SSL (Secure Sockets Layer) для шифрування даних. Це забезпечує конфіденційність та цілісність даних між клієнтом і сервером.<br>
- Використовує порт 443: HTTPS використовує порт 443 для передачі даних.<br>
- Захищає конфіденційність даних: Інформація, яка передається через HTTPS, шифрується, тому навіть якщо дані будуть перехоплені, їх буде важко прочитати без відповідного ключа.<br>
- Використовує сертифікати SSL/TLS: Для встановлення безпечного з'єднання між клієнтом і сервером використовуються цифрові сертифікати SSL/TLS.<br>
- Застосовується для захищеного обміну конфіденційною інформацією: HTTPS в основному використовується там, де потрібна конфіденційність даних, таких як паролі, особиста інформація, фінансові та інші чутливі дані.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке REST API і які його основні принципи?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>REST API (Representational State Transfer Application Programming Interface) - це архітектурний стиль веб-сервісів, який використовує HTTP для передачі даних між клієнтом і сервером. REST API базується на чотирьох основних принципах:<br>
    - Статус коду HTTP - HTTP-відповіді REST API повинні використовувати статус-коди HTTP для інформування клієнта про результат запиту. Наприклад, відповідь із статус-кодом 200 означає, що запит успішно виконаний, відповідь із статус-кодом 400 означає, що запит неправильний, а відповідь із статус-кодом 500 означає, що виникла помилка на сервері.<br>
    - Ресурси - REST API оперує ресурсами, які представляють об'єкти, такі як продукти, користувачі або замовлення. Ресурси ідентифікуються за допомогою URI.<br>
    - Методи HTTP - REST API використовує методи HTTP для визначення операцій, які можна виконувати з ресурсами. Наприклад, метод GET використовується для отримання ресурсу, метод POST використовується для створення ресурсу, а метод PUT використовується для оновлення ресурсу.<br>
    - Сегментація ресурсів - REST API дозволяє сегментувати ресурси за допомогою URI. Наприклад, URI /products/123 представляє продукт з ідентифікатором 123.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке JSON і XML і чим вони відрізняються у використанні?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>JSON (JavaScript Object Notation) і XML (eXtensible Markup Language) є двома різними форматами обміну даними, які використовуються для передачі структурованої інформації між програмами. <br>
    Синтаксис:<br>
    - JSON: Використовує простий синтаксис, що базується на об'єктах та масивах. Дані в JSON представлені у вигляді пар "ключ-значення" і можуть бути вложеними.<br>
    - XML: Має розмітку з використанням тегів, яка може бути більш розгалуженою та складною. Теги можуть мати атрибути, і дані представлені у вигляді деревоподібної структури.<br>
    Читабельність:<br>
    - JSON: Зазвичай менший обсяг даних, легше читати та розуміти для людей.<br>
    - XML: Займає більше місця через використання розмітки, тому може бути менш читабельним.<br>
    Підтримка типів даних:<br>
    - JSON: Підтримує об'єкти, масиви, числа, рядки, булеві значення та значення null.<br>
    - XML: Дозволяє визначати власні типи даних та структури.<br>
    Продуктивність:<br>
    - JSON: Зазвичай швидший у відношенні до обробки даних через його легкий синтаксис.<br>
    - XML: Може бути менш ефективним через більший обсяг розмітки та більшу складність структури.<br>
    Використання:<br>
    - JSON: Зазвичай використовується для обміну даними веб-застосунків, в мовах програмування, таких як JavaScript, Python, і т.д.<br>
    - XML: Широко використовується у різних галузях, зокрема в документообігу, конфігураційних файлах, веб-сервісах, і т.д.
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Як працює механізм CORS (Cross-Origin Resource Sharing)?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Механізм CORS (Cross-Origin Resource Sharing) - це стандарт, який дозволяє веб-сторінкам запитувати ресурси (наприклад, скрипти, стилі або файли зображень) з інших доменів, ніж той, з якого завантажена сама сторінка. Стандарт CORS вперше був представлений для браузерів з метою забезпечення безпеки, обмежуючи можливість використання ресурсів з різних доменів без відповідного дозволу.<br>
Основні кроки роботи CORS:<br>
- Виконання запиту: Коли веб-сторінка робить запит до іншого домену за допомогою JavaScript (наприклад, Ajax-запит), браузер додає до запиту HTTP-заголовок Origin, що містить початковий домен веб-сторінки.<br>
- Перевірка заголовку Origin: Сервер, до якого відправлений запит, перевіряє, чи відповідає домен, вказаний у заголовку Origin, списку дозволених доменів.<br>
- Встановлення заголовків відповіді: Якщо сервер визнає домен як дозволений, він повертає відповідь із спеціальними заголовками CORS, такими як Access-Control-Allow-Origin, який містить список дозволених доменів. Якщо сервер не дозволяє обмін ресурсами, він може повернути помилку.<br>
- Перевірка заголовків відповіді на стороні клієнта: Браузер перевіряє заголовок Access-Control-Allow-Origin у відповіді. Якщо домен веб-сторінки входить до списку дозволених, браузер дозволяє JavaScript-коду отримати доступ до ресурсів та обробляти відповідь.<br>
Якщо запитуваний сервер не підтримує CORS або не дозволяє конкретному домену, браузер видасть помилку, і JavaScript не отримає доступ до відповіді.<br>
Заголовки CORS також можуть містити інші параметри, такі як Access-Control-Allow-Methods (дозволені HTTP-методи), Access-Control-Allow-Headers (дозволені HTTP-заголовки), і інші. Це допомагає точно налаштовувати механізм CORS для конкретних потреб додатка.<br>
Приклади використання CORS:<br>
- Відображення карти з Google Maps<br>
- Завантаження зображень з Flickr<br>
- Відтворення відео з YouTube<br>
  </p>
    </div>
  </details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке WebSocket і в чому його особливості порівняно з традиційними HTTP-запитами?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>WebSocket - це протокол зв'язку, який забезпечує можливість двосторонньої комунікації в режимі реального часу між клієнтом і сервером через одне постійне з'єднання. Він відмінний від традиційних HTTP-запитів за декількома ключовими особливостями:<br>
- Постійне з'єднання (Full-duplex): У випадку WebSocket встановлюється одне постійне з'єднання між клієнтом і сервером, яке залишається відкритим протягом тривалості сесії. Це дозволяє обидвій сторонам відправляти дані одна одній в будь-який момент часу, незалежно від того, хто розпочав комунікацію.<br>
- Низькі затримки (Low latency): WebSocket дозволяє надсилати повідомлення майже миттєво, що робить його ідеальним для використання в реальному часі, таких як чати, стрімінгове відео, гри та інші додатки, які вимагають мінімальної затримки.<br>
Ефективність:<br>
- HTTP-запити: У традиційних HTTP-запитах для отримання оновлень сервера клієнт повинен відправляти повторні запити на сервер або використовувати техніки, такі як довгі опитування (long polling), щоб отримати нові дані.<br>
- WebSocket: Постійне з'єднання WebSocket дозволяє уникнути необхідності в повторних запитах, зменшуючи навантаження на мережу та сервер.<br>
Стандартний протокол:<br>
- HTTP-запити: Клієнт і сервер взаємодіють за допомогою запитів і відповідей.<br>
- WebSocket: Використовує стандартний протокол WebSocket, який вбудований у браузери і сервери, такі як WebSocket API для браузерів та WebSocket сервери.<br>
Захист від Cross-Origin Resource Sharing (CORS): WebSocket може бути використаний для обходу обмежень CORS, оскільки дозволяє взаємодіяти з ресурсами на інших доменах без необхідності великої кількості HTTP-запитів.<br>
Хоча WebSocket і має свої переваги, важливо враховувати, що використання його відповідно до потреб проекту. У деяких випадках, де HTTP вистачає, WebSocket може бути зайвим, адже він додає додатковий рівень складності порівняно з традиційними HTTP-запитами.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Як функціонує кешування вебресурсів?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Кешування вебресурсів - це процес зберігання копій ресурсів (таких як HTML-сторінки, зображення, стилі, скрипти) на локальному пристрої або проміжному сервері (наприклад, проксі-сервері), щоб уникнути повторного завантаження цих ресурсів при наступних запитах. Це може покращити швидкість завантаження сторінок та зменшити навантаження на сервер.<br>
    Основні принципи функціонування кешування вебресурсів:<br>
    При запиті ресурсу:<br>
    Клієнт (браузер) або проксі-сервер робить запит на сервер для отримання певного ресурсу (наприклад, HTML-сторінки, зображення чи стилі).<br>
    Перевірка в кеші:<br>
    Сервер або проксі-сервер перевіряє, чи є копія запитаного ресурсу в кеші на локальному пристрої чи проміжному сервері.<br>
    Повернення з кешу:<br>
    Якщо ресурс знаходиться в кеші і є актуальним (наприклад, не минув термін його дії), сервер або проксі-сервер повертає цей ресурс клієнту без відправлення запиту на віддалений сервер. Це називається "попаданням в кеш" (cache hit).<br>
    Відправлення запиту на сервер:<br>
    Якщо ресурс відсутній в кеші або застарів, сервер або проксі-сервер відправляє запит на віддалений сервер для отримання актуальної версії ресурсу.<br>
    Оновлення кешу:<br>
    Після отримання актуального ресурсу від сервера, його копія може бути збережена в кеші. Оновлення кешу може відбуватися відповідно до різних стратегій (наприклад, використовуючи час життя кешованого ресурсу або інші параметри).<br>
    Кешування дозволяє зменшити час завантаження ресурсів та скоротити використання мережі, зокрема для повторних відвідувань сторінок або однотипних запитів. Однак важливо враховувати, що кешування повинно бути налаштоване правильно, щоб уникнути показу застарілих даних. Також, кешування може бути вимкнене або налаштоване для конкретних ресурсів за допомогою HTTP-заголовків і метатегів.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке SSL/TLS і як це використовують для реалізації безпеки?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>SSL (Secure Sockets Layer) і його еволюційний нащадок TLS (Transport Layer Security) є криптографічними протоколами, призначеними для забезпечення безпеки комунікації в мережі Інтернет. Основною метою SSL/TLS є шифрування даних, аутентифікація сторінок та забезпечення цілісності даних, які передаються між клієнтом і сервером.<br>
    Основні принципи функціонування SSL/TLS:<br>
    - Рукостискання (Handshake): Під час початку з'єднання між клієнтом і сервером відбувається рукостискання, під час якого визначається версія протоколу, обмінюються криптографічні параметри і відбувається аутентифікація.<br>
    - Обмін ключами: Коли клієнт і сервер визначають криптографічні параметри, вони обмінюються публічними ключами для подальшого встановлення общого ключа, який використовується для шифрування і розшифрування даних.<br>
    - Шифрування: Після встановлення общого ключа використовується симетричний шифр для шифрування та розшифрування даних, що передаються між клієнтом і сервером. Це забезпечує конфіденційність і безпеку даних під час їхньої передачі.<br>
    - Аутентифікація: SSL/TLS дозволяє серверам представлятися за допомогою цифрових сертифікатів, що випускаються надійними сертифікаційними центрами. Клієнт може перевірити валідність сертифіката, щоб визначити, чи довіряти серверу.<br>
    - Цілісність даних: Для забезпечення цілісності даних використовуються коди аутентифікації повідомлення (Message Authentication Codes, MACs), які дозволяють визначити, чи були дані змінені під час їхньої передачі.<br>
    SSL був розроблений компанією Netscape і вперше впроваджений в 1995 році. TLS став наступником SSL, і його остання версія на момент моєї останньої оновлення в січні 2022 року - TLS 1.3.<br>
    SSL/TLS використовується для забезпечення безпеки в різних протоколах, таких як HTTPS (HTTP over SSL/TLS), SMTPS (SMTP over SSL/TLS), IMAPS (IMAP over SSL/TLS), та інші. Використання SSL/TLS важливе для захисту конфіденційної інформації під час передачі через неприватні мережі, зокрема в Інтернеті.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Як можна обробляти великі обсяги даних без негативного впливу на продуктивність фронтенду?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Обробка великих обсягів даних на фронтенді може бути викликана різними проблемами, такими як затримки при завантаженні, погана відзивчивість інтерфейсу користувача та інші аспекти, які можуть впливати на продуктивність. Для оптимізації роботи фронтенду з великими обсягами даних рекомендується використовувати наступні стратегії:<br>
    - Пагінація та Безскінечний скролінг: Розділіть великі обсяги даних на сторінки за допомогою пагінації або реалізуйте безскінечний скролінг. Це дозволяє завантажувати лише обмежену кількість записів за раз, зменшуючи тим самим обсяг даних, який потрібно обробляти фронтенду.<br>
    - Ліниве завантаження (Lazy Loading): Завантажуйте дані тільки в той момент, коли вони фактично потрібні. Наприклад, можна використовувати ліниве завантаження для зображень, або завантаження деталей записів лише при їхньому відкритті користувачем.<br>
    - Кешування: Використовуйте кешування для збереження результатів попередніх запитів і уникання повторного завантаження тих самих даних.<br>
    - Оптимізація запитів до сервера: Використовуйте ефективні та оптимізовані запити до сервера, які повертають тільки необхідну інформацію. Використовуйте можливості фільтрації, сортування та обмеження результатів запитів.<br>
    - Використання Віртуалізації Списків: Використовуйте бібліотеки або компоненти, які використовують віртуалізацію списків. Це дозволяє рендерити на екрані лише видиму частину списку, підтримуючи великі набори даних.<br>
    - Оптимізація Рендерингу: Використовуйте мемоізацію та PureComponent для уникнення непотрібного рендерингу компонентів. Це може покращити продуктивність, особливо при частих змінах стану.<br>
    - Web Workers: Використовуйте Web Workers для виконання обчислювально важливих завдань в окремому потоці, не блокуючи основний потік веб-браузера.<br>
    - Оптимізація Зображень: Компресуйте та оптимізуйте зображення перед їхнім завантаженням на фронтенд.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Поясніть кожну складову SOLID.
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>SOLID - це акронім, який представляє п'ять базових принципів об'єктно-орієнтованого програмування та дизайну, розроблених Робертом С. Мартіном. Кожен принцип розкриває важливий аспект дизайну об'єктів та сприяє створенню гнучких, легко розширюваних та обслуговуваних систем. Ось пояснення кожного принципу SOLID:<br>
  1. **Принцип єдиної відповідальності (Single Responsibility Principle - SRP):**
    - Цей принцип стверджує, що клас повинен мати лише одну причину для зміни. Кожен клас повинен виконувати лише одну функцію або завдання. Це сприяє виокремленню різних аспектів системи та полегшує їхнє розширення та обслуговування.<br>
  2. **Принцип відкритості/закритості (Open/Closed Principle - OCP):**
    - Система повинна бути відкритою для розширення, але закритою для змін. Це означає, що класи можна розширювати, додаючи новий функціонал, але не слід змінювати вже існуючий код. Введення абстракцій та використання інтерфейсів допомагають досягти цього принципу.<br>
  3. **Принцип заміщення Лісков (Liskov Substitution Principle - LSP):**
    - Об'єкти базового класу повинні можливо найкраще заміщати об'єкти його похідних класів без зміни коректності програми. Це означає, що класи-спадкоємці повинні вести себе так само, як і їхні базові класи.<br>
  4. **Принцип інтерфейсів (Interface Segregation Principle - ISP):**
    - Принцип передбачає, що клієнти не повинні залежати від інтерфейсів, які вони не використовують. Краще визначати більше спеціалізованих інтерфейсів для конкретних клієнтів, ніж один загальний для всіх випадків. Це дозволяє уникнути непотрібних залежностей та робить систему більш гнучкою.<br>
  5. **Принцип інверсії залежностей (Dependency Inversion Principle - DIP):**
    - Принцип передбачає, що модулі високого рівня не повинні залежати від модулів низького рівня. Обидва повинні залежати від абстракцій. Абстракції не повинні залежати від подробиць. Подробиці повинні залежати від абстракцій. Введення інтерфейсів та використання зворотного виклику (callback) є одними з методів досягнення цього принципу.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке code smells?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>"Code smells" (запахи коду) — це поняття, яке використовується в програмуванні для опису певних ознак або патернів в коді, які можуть свідчити про його можливі проблеми або неоптимальність. Коли в коді з'являються "запахи", це може бути індикатором того, що код може бути покращений, оптимізований або переписаний.<br>
    Деякі типові "запахи коду" включають:<br>
    1. **Дублювання (Duplicate Code):**
      - Коли один і той же або схожий код повторюється в різних частинах програми, це може призводити до складнощів у підтримці та розширенні коду.<br>
    2. **Довгі Функції (Long Method):**
      - Функції або методи, які стають занадто великими та важкими для розуміння. Довгі функції можуть бути складні для тестування та підтримки.<br>
    3. **Великі Класи (Large Class):**
      - Класи, які мають занадто багато відповідальностей або поля, можуть стати важкими для розуміння та управління.<br>
    4. **Запутаний Код (Complex Code):**
      - Код, який використовує заплутані умови, вкладені цикли або занадто складні конструкції, може бути важким для розуміння та тестування.<br>
    5. **Непотрібні Коментарі (Unnecessary Comments):**
      - Якщо код потребує багато коментарів для пояснення, це може свідчити про його низьку якість та читабельність.<br>
    6. **Непотрібні Залежності (Unnecessary Dependencies):**
      - Зайва залежність від бібліотек або інших компонентів може ускладнювати код та збільшувати його об'єм.<br>
    7. **Використання Глобальних Змінних (Global Variables):**
      - Використання глобальних змінних може призводити до проблем з розумінням та управлінням станом програми.<br>
    8. **Недостатня Інкапсуляція (Incomplete Encapsulation):**
      - Якщо структури даних частково інкапсульовані або відкриті для прямого доступу, це може порушувати принципи об'єктно-орієнтованого програмування.<br>
    Виявлення "запахів коду" може бути важливою частиною процесу розробки, оскільки це допомагає вчасно виявляти проблеми та покращувати якість коду.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке мікророзмітка?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Мікророзмітка (Microdata) — це один із форматів мітаданих, який використовується для додавання структурованої інформації до веб-сторінок. Мета мікророзмітки полягає в тому, щоб зрозуміти контент веб-сторінки для пошукових систем, браузерів та інших програм, які використовують дані з Інтернету.<br>
    Основні особливості мікророзмітки:<br>
    1. **Структуровані Дані:**<br>
      - Мікророзмітка дозволяє вбудовувати в HTML-код структуровані дані, які можна інтерпретувати та використовувати машинами для кращого розуміння контенту сторінки.<br>
    2. **Використання Різних Видів Схем:**
      - Існує кілька видів схем мікророзмітки, таких як Schema.org, Microformats, RDFa тощо. Schema.org є найбільш поширеним та підтримуваним стандартом.<br>
    3. **Покращення Пошукової Видимості:**
      - Використання мікророзмітки може покращити відображення ваших сторінок у пошукових результатах. Наприклад, для організацій мікророзмітка може містити назву, адресу, телефон, робочі години тощо.<br>
    Приклад мікророзмітки для вказання інформації про організацію за допомогою Schema.org:
   <pre>
    div itemscope itemtype="http://schema.org/Organization"
      span itemprop="name" Назва Організації span
      div itemprop="address" itemscope itemtype="http://schema.org/PostalAddress"
        span itemprop="streetAddress" Адреса організації span
        span itemprop="addressLocality" Місто span
        span itemprop="addressRegion" Регіон span
        span itemprop="postalCode" Поштовий індекс span
      div
      span itemprop="telephone" Телефон організації span
    div
    </pre>
  </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Як використовуєте prefetching і preloading ресурсів для підвищення швидкості переходу між сторінками?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Prefetching і preloading - це техніки оптимізації завантаження ресурсів для поліпшення швидкості переходу між сторінками. Вони дозволяють попередньо завантажити ресурси, які ймовірно будуть потрібні на наступній сторінці, що дозволяє зменшити затримку при навігації. Однак їх слід використовувати обережно, оскільки завантаження зайвих ресурсів може вплинути на загальний обсяг передачі даних та продуктивність.<br>
    - Prefetching: Prefetching вказує браузеру завантажувати ресурси, які ймовірно будуть потрібні на наступних сторінках. Це може бути викликано через тег link у head сторінки:<br>
    <pre>link rel="prefetch" href="next-page.html"</pre>
    В цьому прикладі ресурс next-page.html буде попередньо завантажено браузером, коли поточна сторінка завантажиться.<br>
    - Preloading: Preloading дозволяє вам завантажити ресурси, необхідні для поточної сторінки, якщо ви впевнені, що вони будуть потрібні найближчим часом. Це також може бути викликано через link тег у head:<br>
    <pre>link rel="preload" href="critical-style.css" as="style" onload="this.onload=null;this.rel='stylesheet'"</pre>
    У цьому прикладі ресурс critical-style.css буде завантажено асинхронно та застосовано як таблиця стилів після завантаження.
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке CI/CD?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>CI/CD вказує на практику Continuous Integration та Continuous Delivery (або Continuous Deployment), яка спрямована на автоматизацію процесу розробки та розгортання програмного забезпечення.<br>
    1. **Continuous Integration (CI):**
      - Це практика, при якій код розробників регулярно інтегрується у спільний репозитарій (зазвичай кілька разів на день). Після кожного злиття коду в репозитарій виконується автоматична перевірка, яка включає компіляцію, тестування та інші види аналізу якості коду. Мета - виявлення та виправлення конфліктів та помилок якнайшвидше, а не чекання до завершення всього проекту.<br>
    2. **Continuous Delivery (CD):**
      - Це практика, за якої забезпечується, що програмне забезпечення завжди готове до релізу. Після завершення процесу CI, якщо всі тести пройдені успішно, програмне забезпечення автоматично готується до релізу. Це включає в себе створення збірки, підготовку середовища, автоматичне тестування та інші кроки, необхідні для розгортання програмного забезпечення в продакшн.<br>
    3. **Continuous Deployment (CD):**
      - Це розширення Continuous Delivery, при якому програмне забезпечення автоматично розгортається в продакшн після завершення кожного успішного циклу CI/CD. У випадку Continuous Delivery розгортання в продакшн відбувається тільки після ручного схвалення, тоді як у Continuous Deployment цей процес абсолютно автоматизований та не вимагає втручання розробників.<br>
    Отже, CI/CD створює автоматизований та надійний шлях від написання коду до випуску програмного забезпечення в продакшн, що сприяє якості, стабільності та швидкості розробки.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке мікросервісна архітектура, що таке монолітна, різниця і переваги?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>**Мікросервісна архітектура:**
    Мікросервісна архітектура - це підхід до розробки програмного забезпечення, при якому додаток розбивається на невеликі, самостійні та незалежні компоненти, відомі як мікросервіси. Кожен мікросервіс виконує конкретні функції та взаємодіє з іншими мікросервісами через API. Ця архітектура спрощує розробку, тестування та впровадження змін, а також полегшує масштабування та підтримку додатку.<br>
    **Монолітна архітектура:**
    Монолітна архітектура - це традиційний підхід, при якому весь додаток розташований в єдиному блоку коду. Усі функції та компоненти спільно працюють, і будь-які зміни або оновлення вносяться в єдиний кодову базу. Монолітна архітектура є простішою з точки зору розробки та деплою, але може стати обмеженням у великих та складних проектах.<br>
    **Різниця і переваги:**<br>
    1. **Розмір та складність:**<br>
      - Мікросервіси: Додаток розбивається на менші та незалежні частини, що полегшує розробку та масштабування.<br>
      - Моноліт: Усі функції розташовані в одному блоку коду, що може призводити до зростання складності при збільшенні розміру проекту.<br>
    2. **Гнучкість та масштабованість:**<br>
      - Мікросервіси: Незалежність мікросервісів дозволяє гнучко розгортати та масштабувати окремі компоненти.<br>
      - Моноліт: Зазвичай менш гнучкий та важше масштабується.<br>
    3. **Легше вдосконалення та оновлення:**<br>
      - Мікросервіси: Оновлення можливо надаючи новий функціонал чи оновлення окремого мікросервісу.<br>
      - Моноліт: Зміни вносяться в єдиний кодову базу, що може вплинути на всі аспекти додатку.<br>
    4. **Відновлення та стійкість до помилок:**<br>
      - Мікросервіси: Якщо один мікросервіс відмовляє, інші можуть продовжити працювати, що забезпечує стійкість до помилок.<br>
      - Моноліт: Відмова в одному компоненті може вплинути на всю систему.<br>
    5. **Технологічне різноманіття:**<br>
      - Мікросервіси: Дозволяють використовувати різні технології для кожного мікросервісу.<br>
      - Моноліт: Одна технологія для всього додатку.<br>
    Обираючи між цими архітектурами, команди повинні враховувати конкретні вимоги проекту, масштабу та потреби в гнучкості та швидкості розробки.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Які патерни проєктування ви знаєте і де їх застосовувати?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>
Factory Method: визначає загальний інтерфейс для створення об'єктів у суперкласі, дозволяючи підкласам змінювати тип створюваних об'єктів. Можна використовувати для створення різних типів елементів інтерфейсу користувача, наприклад, кнопок, текстових полів та списків.<br>
Singleton: забезпечує створення лише одного екземпляра класу. Можна використовувати для забезпечення єдиного доступу до ресурсу, наприклад, до глобальної змінної або до об'єкта, який представляє глобальний стан програми.<br>
Adapter: дозволяє об'єктам з несумісними інтерфейсами взаємодіяти між собою. Дає змогу створювати різні сімейства об'єктів, не залежно від їхньої реалізації. Можна використовувати для забезпечення взаємодії між об'єктами з різними інтерфейсами, наприклад, для взаємодії між об'єктом, який використовує інтерфейс DOM, та об'єктом, який використовує інтерфейс, визначений користувачем.<br>
Decorator: дозволяє додавати нові можливості об'єктам без зміни їхньої реалізації. Можна використовувати для додавання нових можливостей об'єктам, наприклад, для додавання логування до об'єктів або для додавання підтримки нових властивостей до об'єктів.
</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Поясніть принципи Cross-Site Scripting (XSS) і Cross-Site Request Forgery (CSRF) атаки та способи захисту від них.
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>**Cross-Site Scripting (XSS):**<br>
XSS - це атака, при якій зловмисник вбудовує в веб-сторінку скрипти, які виконуються в контексті браузера користувача. Це може призвести до виконання зловмисником шкідливого коду на боковому браузері користувача, отримання доступу до конфіденційної інформації, виконання операцій в імені користувача тощо.<br>
Принцип атаки:<br>
1. **Вбудовування скрипта:** Зловмисник вставляє в веб-сайт (часто через введення даних в форми) JavaScript-код, який виконається в браузері іншого користувача.<br>
2. **Виконання в контексті користувача:** Скрипт виконується в контексті сесії користувача, що дозволяє зловмиснику отримувати доступ до конфіденційних даних або виконувати дії в імені користувача.<br>
Способи захисту від XSS:<br>
- **Фільтрація та екранування введених даних:** Всі введені дані веб-сайту повинні бути фільтровані та екрановані перед виведенням.<br>
- **Content Security Policy (CSP):** Встановлення CSP-заголовка, який обмежує, які ресурси можуть бути використані на сторінці, включаючи виборочне блокування виконання JavaScript.<br>
- **HttpOnly Cookies:** Використання HttpOnly-атрибута для cookies, який ускладнює зловмиснику отримання доступу до кукізів через JavaScript.<br>
**Cross-Site Request Forgery (CSRF):**<br>
CSRF - це атака, при якій атакуючий використовує довіру веб-сайту до користувача для виконання неавторизованих дій в імені цього користувача.<br>
Принцип атаки:<br>
1. **Використання авторизованого сеансу:** Зловмисник використовує авторизований сеанс користувача без його знання.<br>
2. **Виведення користувача на спеціально підготовлену сторінку:** Наприклад, через відправку шкідливого посилання або вставлення у веб-сторінку з фреймом.<br>
3. **Виконання небажаної дії:** Користувач, не підозрюючи, виконує небажану дію (наприклад, змінює пароль, виводить гроші тощо).<br>
Способи захисту від CSRF:<br>
- **Використання токенів захисту:** Включення в кожний запит, що змінює стан сервера, унікального токену захисту (CSRF токен), який перевіряється сервером.<br>
- **SameSite Cookies:** Використання атрибута SameSite для обмеження передачі cookies тільки при запитах з одного та того ж джерела.<br>
- **Проведення двофакторної аутентифікації (2FA):** Збільшує важкість успішного використання уразливостей в CSRF-атаках.
Правильне використання цих заходів допоможе підвищити безпеку веб-додатків та запобігти атакам XSS і CSRF.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке токен, як він використовується в браузері?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>В контексті веб-розробки та безпеки, токен - це деякий набір даних, який виданий автентифікаційним сервером та використовується для підтвердження ідентифікації та отримання доступу до ресурсів. Токени широко використовуються для різноманітних цілей, таких як автентифікація, авторизація, ідентифікація та забезпечення безпеки.<br>
    У веб-розробці два основні типи токенів використовуються в браузерах: токени автентифікації (наприклад, JWT) та токени сесії (наприклад, кукізи).<br>
    1. **Токени автентифікації (Auth Tokens):**<br>
      - **JWT (JSON Web Token):** JWT - це компактний, самостійний, відкритий стандарт (RFC 7519) для передачі інформації між двома сторонами у вигляді об'єкта JSON. Використовується для передачі підписаних даних між сторонами так, щоб можна було перевірити їхню достовірність та впевнитися, що дані не були змінені.<br>
      - **Використання в браузері:** Токени автентифікації зазвичай зберігаються в браузері як кукізи (в основному HttpOnly та Secure cookies) або у локальному сховищі (LocalStorage або SessionStorage). Якщо токен у форматі JWT, то його можна декодувати та отримати інформацію про користувача без потреби звертатися до сервера при кожному запиті.<br>
    2. **Токени сесії (Session Tokens):**<br>
      - **Кукізи (Cookies):** Кукізи - це невеликі файли, які зберігаються в браузері та надсилаються разом із кожним запитом до сервера. Їх використовують для збереження інформації про сесію, автентифікації та стану користувача.<br>
      - **Використання в браузері:** Кукізи зазвичай використовуються для збереження ідентифікатора сесії, який сервер використовує для відстеження стану користувача. Кукізи можуть мати обмеження доступу, такі як HttpOnly (заборона доступу з JavaScript) або Secure (для HTTPS).<br>
    Токени використовуються для забезпечення безпеки та конфіденційності у веб-додатках. Їх використання дозволяє зберігати інформацію про користувача або сесію в зашифрованому вигляді та передавати її між браузером та сервером з використанням стандартних протоколів та безпечних практик.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Натисни, щоб відкрити/закрити текст
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>ARIA (Accessible Rich Internet Applications) — це набір стандартів, розроблений консорціумом W3C, який допомагає забезпечити доступність та полегшити взаємодію користувачів з обмеженими можливостями інтернет-додатками, особливо тими, які використовують технології AJAX, JavaScript і динамічний HTML.<br>
ARIA ролі — це одна з основних функцій ARIA, що дозволяє розробникам вказувати ролі та стан елементів на сторінці для забезпечення правильного їх інтерпретації агентами користувачів, такими як скрінрідери.<br>
Основні категорії ARIA ролей включають:<br>
1. **Widget Roles (Ролі віджетів):** Використовуються для визначення інтерактивних елементів та введення, таких як кнопки, чекбокси, комбіновані списки і т. д.<br>
   Приклади:<br>
   - `role="button"` для визначення кнопок.<br>
   - `role="checkbox"` для визначення чекбоксів.<br>
   - `role="slider"` для визначення слайдерів.<br>
2. **Document Structure Roles (Ролі структури документу):** Використовуються для визначення структури документа та його елементів.<br>
   Приклади:<br>
   - `role="main"` для визначення основного контенту на сторінці.<br>
   - `role="navigation"` для визначення навігаційного блоку.<br>
3. **Live Region Roles (Ролі областей оновлення):** Використовуються для визначення областей, які динамічно оновлюються або дозволяють введення користувача.<br>
   Приклади:<br>
   - `role="alert"` для визначення областей, які містять важливі повідомлення.<br>
   - `role="status"` для визначення статусу документа або додатку.<br>
4. **Landmark Roles (Ролі орієнтирів):** Використовуються для визначення основних розділів або блоків сторінки для полегшення навігації.<br>
   Приклади:<br>
   - `role="banner"` для визначення верхнього банера на сторінці.<br>
   - `role="contentinfo"` для визначення інформації про контент.<br>
5. **Window Roles (Ролі вікна):** Використовуються для визначення областей взаємодії або окремих вікон.<br>
   Приклад:<br>
   - `role="dialog"` для визначення діалогового вікна.<br>
Використання ARIA ролей дозволяє покращити доступність додатків, особливо тих, які використовують складні інтерфейси та динамічний контент.</p>
  </div>
</details>
