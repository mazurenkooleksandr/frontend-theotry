<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке MobX і як він відрізняється від інших бібліотек для керування станом?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>MobX - це бібліотека для управління станом в додатках, написаних на JavaScript або TypeScript. Головна ідея MobX - це зробити управління станом простим і ефективним, забезпечуючи автоматичну реактивність.<br>
    Основні характеристики MobX:<br>
    - Реактивність: MobX використовує концепцію реактивності, щоб автоматично визначати, коли і які частини стану потрібно оновлювати при зміні даних. Це дозволяє створювати код, який реагує на зміни стану без вручну написаного коду для визначення оновлень.<br>
    - Простота використання: MobX призначений для зручного використання і має простий API. Він не вимагає великої кількості додаткового коду для визначення стору та оновлення його стану.<br>
    - Декларативний підхід: Ви описуєте ваш стан та логіку зміни стану декларативно, використовуючи MobX-анотації (зокрема, декоратори, як-то @observable, @computed, і @action).<br>
    - Вирішення проблем "грязного стану": MobX робить важливий акцент на тому, щоб мати єдиний, зрозумілий джерело правди (Single Source of Truth) в додатку, уникнувши так званого "грязного стану".<br>
    Порівняно з іншими бібліотеками управління станом, такими як Redux, MobX часто вважається більш простим у використанні та має менше "церемоній" коду. Він дозволяє зосереджуватися на логіці додатку, замість того, щоб вирішувати питання, як правильно розділити дії, редюсери та джерела даних.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Які основні принципи роботи MobX?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>MobX працює на основі декларативного та реактивного підходів. Основні принципи роботи MobX можна узагальнити наступним чином:<br>
    - Реактивність (Reactivity): Одним з ключових принципів MobX є використання реактивності. Коли ви оголошуєте частину вашого стану, яка може змінюватися (observable), MobX автоматично встановлює відстеження цих змін. Це дозволяє автоматично перерендерювати відповідні частини вашого інтерфейсу користувача або викликати інші зміни, які пов'язані зі змінами стану.<br>
    - Декларативність (Declarative): MobX підтримує декларативний підхід до визначення стану та логіки зміни стану. Ви можете використовувати декоратори (такі як @observable, @computed, і @action), щоб декларативно вказати, які частини стану є спостережуваними (observable), які є обчислюваними значеннями (computed), і які методи забезпечують зміну стану (actions).<br>
    - Атомарні зміни (Atomic Changes): MobX рекомендує робити зміни стану в рамках атомарних операцій (actions). Це означає, що всі зміни стану повинні бути виконані як єдина транзакція, яка гарантує, що всі відстежувачі (observers) будуть сповіщені про зміни тільки після завершення всіх змін.<br>
    - Спрощена модель об'єкта (Simplified Object Model): MobX спрощує модель об'єкта, дозволяючи оголошувати об'єкти зі спостережуваними властивостями. Це зменшує кількість "лишнього" коду, який інакше був би необхідний для роботи зі станом.<br>
    - Відсутність необхідності у додаткових концепціях: В порівнянні з іншими бібліотеками керування станом, MobX робить акцент на відсутності необхідності у додаткових концепціях, таких як редюсери або середовища дій. Все, що вам потрібно, це декларувати свій стан та методи його зміни.
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке MobX-спостерігачі(observable) і для чого вони використовуються?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>MobX-спостерігачі (observers) є частиною концепції реактивності в MobX. Спостерігачі - це функції або компоненти, які автоматично перерендерюються або викликаються при зміні спостережуваного значення, яке вони відстежують. Основна ідея полягає в тому, що коли спостережуване значення змінюється, всі його спостерігачі повідомляються про цю зміну і автоматично оновлюють себе.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке стор в MobX?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>У контексті MobX термін "стор" (store) використовується для позначення об'єкта, який містить стан додатка та логіку його зміни. Стор - це зручний спосіб організації та управління станом в MobX.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Які переваги має MobX перед Redux?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>
    1. Простота використання:<br>
    - MobX: Вважається більш простим та легким для використання. MobX не вимагає багато шаблонного коду, і його API може здаватися менш складним для новачків.<br>
    - Redux: Має більше "церемонійного" коду, такого як дії, редюсери та магазини, що може вимагати більше часу для вивчення та розуміння.<br>
    2. Реактивність:<br>
    - MobX: Має вбудовану підтримку реактивності, що дозволяє автоматично визначати, коли перерендерювати компоненти або викликати інші зміни відповідно до змін стану.<br>
    - Redux: Реактивність в Redux може бути досягнута за допомогою middleware або бібліотек, таких як Redux Observable чи Redux Saga.<br>
    3. Декларативний підхід:<br>
    - MobX: Має більш декларативний підхід до визначення та оновлення стану. Використання декораторів (зокрема, декораторів MobX) дозволяє декларативно вказувати, які частини стану слід відстежувати та оновлювати.<br>
    - Redux: Має більш імперативний підхід, де потрібно ретельно керувати діями, редюсерами та контейнерами.<br>
    4. Швидкість розробки:<br>
    - MobX: Зазвичай забезпечує швидший процес розробки завдяки простоті та меньшому обсягу коду.<br>
    - Redux: Може вимагати більше часу на конфігурацію та розробку через більш велику кількість концепцій.<br>
    5. Адаптивність:<br>
    - MobX: Легше адаптується до різних підходів та стилів програмування. Може бути використаний у мікросервісних архітектурах.<br>
    - Redux: Має більш жорсткі конвенції, що може обмежити адаптивність в різних контекстах.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Які декоратори MobX ви використовуєте, і як вони допомагають у розробці?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Декоратори MobX - це анотації, які можна використовувати для позначення різних типів об'єктів та їх властивостей. Вони спрощують синтаксис та збільшують читабельність коду. Ось кілька основних декораторів MobX та їх призначення:<br>
    1. @observable (спостережені властивості):<br>
    - Використовується для визначення змінних, які будуть спостерігати за їхніми змінами.<br>
    - Допомагає автоматично визначати залежності та оновлювати відповідні компоненти при змінах.<br>
    2. @computed (обчислені значення):<br>
    - Використовується для визначення обчислюваних значень, які автоматично оновлюються при змінах в їхніх залежностях.<br>
    - Допомагає зменшити необхідність вручну визначати, коли та як оновлювати певні значення.<br>
    3. @action (дії):<br>
    - Використовується для визначення методів, які змінюють спостережуваний стан.<br>
    - Забезпечує гарантію того, що всі зміни стану відбуваються як єдина транзакція.<br>
    4. @autorun (автоматичні виклики):<br>
    - Використовується для автоматичного виклику функції при кожній зміні залежностей.<br>
    - Допомагає автоматизувати реакцію на зміни стану.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Як ви реагуєте на зміни стану в MobX?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>У MobX я реагую на зміни стану за допомогою спостерігачів(observable). Спостерігачі - це функції, які викликаються всякий раз, коли змінюється стан. Я можу використовувати спостерігачі, щоб оновити свій стан або поведінку відповідно до змін у стані.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке observable в mobx?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Observable в MobX вказує на те, що об'єкт або значення є спостережуваним, тобто його зміни відслідковуються. Функція observable приймає об'єкт чи масив і повертає його "спостережувану" версію. Для чого це потрібно: <br>
    1. Автоматичний перерендерінг компонентів React: Якщо ви використовуєте MobX з React, ви можете робити ваші компоненти "реактивними", тобто вони будуть автоматично перерендерюватися, коли дані, які вони використовують, змінюються.<br>
    2. Простота відслідковування стану: MobX робить простим відслідковування змін в стані програми. Вам не потрібно вручну визначати та підтримувати багато коду для обновлення ваших інтерфейсів при змінах.<br>
    3. Управління станом додатків: Використання "observable" дозволяє зручно управляти станом вашого додатка, а MobX буде відповідати за автоматичне оновлення ваших інтерфейсів.
    <pre>
    import { observable } from 'mobx';
    const store = observable({
      // Спостережувані властивості
      name: 'John',
      age: 25,
      //...
    });
    // Зміни властивостей будуть автоматично відстежуватися
    store.name = 'Jane';
    </pre></p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке observer і для чого в mobx?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>В MobX React існує спеціальна функція observer, яка використовується для зручної інтеграції з React. В MobX, функція observer приймає компонент React і повертає новий компонент React, який автоматично буде перерендерюватися при зміні спостеріганих даних (observable) в MobX. Ця функція дозволяє автоматично перерендерювати компонент, коли відбувається зміна в MobX-спостерігачах (observable). Вона використовує паттерн спостерігача (Observer pattern) для визначення залежностей компонента від даних та автоматичного перерендерення при їх зміні.
    <pre>
    import { observer } from 'mobx-react';
    import { observable } from 'mobx';
    import React from 'react';
    const myStore = observable({
      data: 'Initial data',
      updateData: function(newData) {
        this.data = newData;
      },
    });
    const MyComponent = observer(({ store }) => (
      div
        p{store.data}p
        button onClick={() => store.updateData('New data')}
          Update Data
        button
      div
    ));
    // Використання компонента
    MyComponent store={myStore};
    </pre></p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке computed?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>computed в MobX - це концепція, яка дозволяє створювати обчислювальні властивості, залежні від інших даних в MobX, які автоматично оновлюються.
    <pre>
    import { observable, computed } from 'mobx';
      class MyStore {
        @observable width = 10;
        @observable height = 20;
        @computed get area() {
          return this.width * this.height;
        }
      }
      const myStore = new MyStore();
      console.log(myStore.area); // Виведе: 200
      myStore.width = 15;
      console.log(myStore.area); // Автоматично оновиться до: 300
    </pre>
    В MobX, computed - це функція, яка створює обчислювальну властивість (computed property). Обчислювальні властивості особливо корисні, коли вам потрібно створити значення, яке залежить від інших даних, але ви хочете, щоб MobX автоматично відстежував цю залежність і викликав перерахунок, коли необхідно. Такий підхід сприяє автоматизації управління станом та спрощує код.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке action?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>У MobX, action - це функція або декоратор, яка визначає дію, яка може мутувати стан MobX. Функція action розширює область дії (action context), де зміни в спостережуваних (observable) об'єктах автоматично фіксуються.
    <pre>
    import { observable, action } from 'mobx';
        class MyStore {
          @observable count = 0;
          @action increment() {
            this.count += 1;
          }
          @action decrement() {
            this.count -= 1;
          }
        }
        const myStore = new MyStore();
        console.log(myStore.count); // Виведе: 0
        myStore.increment();
        console.log(myStore.count); // Виведе: 1
        myStore.decrement();
        console.log(myStore.count); // Виведе: 0
    </pre>
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке action.bound?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>action.bound - це декоратор в MobX, який автоматично зв'язує дії (actions) з екземпляром класу. В основному це забезпечує автоматичне виведення дій в контексті екземпляра класу, що їх містить, і робить їх "прив'язаними" до цього екземпляра.<br>
    Для чого використовується action.bound?<br>
    Використання action.bound зручно в тих випадках, коли вам потрібно передавати метод класу як обробник події, колбек чи іншу функцію, і ви хочете, щоб this у внутрішньому коді методу відносилось до екземпляра класу. Декоратор робить це автоматично, дозволяючи уникнути проблеми з втратою контексту та неправильною роботою коду.<br>
    <pre>
    import { observable, action } from 'mobx';
      class MyStore {
        @observable count = 0;
        @action.bound
        increment() {
          this.count += 1;
        }
        @action.bound
        decrement() {
          this.count -= 1;
        }
      }
      const myStore = new MyStore();
      console.log(myStore.count); // Виведе: 0
      const incrementFunction = myStore.increment;
      incrementFunction();
      console.log(myStore.count); // Виведе: 1
      const decrementFunction = myStore.decrement;
      decrementFunction();
      console.log(myStore.count); // Виведе: 0
    </pre>
  </div>
</details>
