<h2>React</h2>

<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useState?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це хук, який дозволяє додавати змінну стану до компонента. useState приймає початковий стан і повертає масив із двома елементами</p>
    <pre>const [count, setCount] = useState(0);</pre>
    <ul>
    <li>Поточний стан змінної стану <code>state</code></li>
    <li>Функція, яка використовується для оновлення стану <code>setState</code></li>
    </ul>
    <p><code>setState</code> - приймає тільки один аргумент. Він асинхронний, щоб уникнути зациклення рендерингу. Коли викликаєте setState, React додає змінну стану. Потім реакт рендерить компонент, коли черга змінна стану буде порожньою. setState асинхронний з двох основних причин: для підвищення продуктивності, для забезпечення атомарності(означає, що оновлення стану відбувається як єдина операція). Якщо потрібно синхронно оновлювати стан, використовуйте useReducer. 
    <code>state</code> -  це сутність, яка зберігає динамічні дані компонента React і дозволяє компоненту  відстежувати зміни між рендерами. <code>setState</code> відстежує зміни між рендерами за допомогою черги змін стану. Коли викликаєте <code>setState</code>, реакт додає зміну стану до черги змін стану. Реакт потім рендерить компоненти, коли черга змін стану буде порожня.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useEffect?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
  <pre>  
  useEffect(() => {
    // code...
  }, []);
  </pre>
    <p>Це хук, який дозволяє виконувати side effects(побічні ефекти) у функціональних компонентах. </br>Побічні ефекти - це дії, які змінюють середовище, наприклад, таймери, викликання сторонніх бібліотек, запис у базу даних або зміни у DOM. useEffect приймає два аргументи. </br>Перший аргумент - це функція, яка виконується при першому рендері компонента. </br>Другий аргумент - це масив залежностей, які визначаються, коли хук повинен бути викликаний повторно.</br>useEffect є асинхронний з двох основних причин: для підвищення продуктивності, для забезпечення атомарності(означає, що оновлення стану відбувається як єдина операція), якщо потрібно викликати зміни синхронно використовуйте useLayoutEffect.</br>useEffect має два життєвих цикла: монтування(componentDidMount()) та оновлення(componentDidUpdate()). Щоб зробити видалення(componentWillUnmount()) можна використовувати функцію з очисткою, ця функція буде викликана при розмонтуванні компонента.</br>
    <pre>  
    useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(intervalId); // розмонтування

}, []);

  </pre>
  </p>
  </div>
</details>
