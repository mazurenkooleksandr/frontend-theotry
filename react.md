<h2>React</h2>

<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useState?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це хук, який дозволяє додавати змінну стану до компонента. useState приймає початковий стан і повертає масив із двома елементами</p>
    <pre>const [count, setCount] = useState(0);</pre>
    <ul>
    <li>Поточний стан змінної стану <code>state</code></li>
    <li>Функція, яка використовується для оновлення стану <code>setState</code></li>
    </ul>
    <p><code>setState</code> - приймає тільки один аргумент. Він асинхронний, щоб уникнути зациклення рендерингу. Коли викликаєте setState, React додає змінну стану. Потім реакт рендерить компонент, коли черга змінної стану буде порожньою. setState асинхронний з двох основних причин: для підвищення продуктивності, для забезпечення атомарності(означає, що оновлення стану відбувається як єдина операція). Якщо потрібно синхронно оновлювати стан, використовуйте useReducer. 
    <code>state</code> -  це сутність, яка зберігає динамічні дані компонента React і дозволяє компоненту  відстежувати зміни між рендерами. <code>setState</code> відстежує зміни між рендерами за допомогою черги змін стану. Коли викликаєте <code>setState</code>, реакт додає зміну стану до черги змін стану. Реакт потім рендерить компоненти, коли черга змін стану буде порожня.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useEffect?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <pre>  
      useEffect(() => {
        // code...
      }, []);
    </pre>
    <p>Це хук, який дозволяє виконувати side effects(побічні ефекти) у функціональних компонентах. </br>Побічні ефекти - це дії, які змінюють середовище, наприклад, таймери, викликання сторонніх бібліотек, запис у базу даних або зміни у DOM. 
    </br>useEffect приймає два аргументи. </br>Перший аргумент - це функція, яка виконується при першому рендері компонента. </br>Другий аргумент - це масив залежностей, які визначаються, коли хук повинен бути викликаний повторно.</br>useEffect є асинхронний з двох основних причин: для підвищення продуктивності, для забезпечення атомарності(означає, що оновлення стану відбувається як єдина операція), якщо потрібно викликати зміни синхронно використовуйте useLayoutEffect.</br>useEffect має два життєвих цикла: монтування(componentDidMount()) та оновлення(componentDidUpdate()). Щоб зробити видалення(componentWillUnmount()) можна використовувати функцію з очисткою, ця функція буде викликана при розмонтуванні компонента.</br>
    <pre>  
      useEffect(() => {
      const intervalId = setInterval(() => {
        setCount(count + 1);
      }, 1000);
      return () => clearInterval(intervalId); // розмонтування
      }, []);
  </pre>
   Зазвичай в useEffect роблять запити до бекенду.
  </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useMemo?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
  <pre>  const memoizedResult = useMemo(() => {
    const calculation = input * input * input;
    return calculation;
  }, [input]);
  </pre>
    <p>Це хук, який дозволяє зберігати результат обчислення в кеші. </br>Функція обчислення - це функція буде викликатись лише один раз, коли значення стану зміниться.</br> Масив залежностей - P.S. Якщо жодна з залежностей не зміниться, то useMemo поверне, те саме значення, що було в попередньому рендерингу. </br> useMemo синхронний.</br> Різниця між useMemo та memo:
    </br>useMemo - повертає закешований результат обчислення. </br> memo - це компонент реакт, який приймає компонент в якості вхідного значення та повертає закешований компонент, працює гарно у звязці з useCallback.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useRef?
  </summary>
  <pre>
    const inputRef = useRef(null);
  </pre>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це хук, який дозволяє створювати та зберігати посилання на обєкт, який залишається не змінним між рендерами. Зміни у useRef не призводять до перерендерингу компонента. </br> useRef повертає обєкт ref з одним атрибутом current, який початково встановлює значення, яке вказали.</br> Основне використання useRef:</br>Зберігання посилань на DOM елементи.</br> Зберігання значення між рендерами без їх впливу на перерендеринг.</br> Зберігання handler(обробників) для DOM подій.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useContext?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <pre>
      // Create a context for global state
      const ThemeContext = createContext('light');
      const theme = useContext(ThemeContext);
    </pre>
    <p>Це хук, який дозволяє компонентам зручно отримувати доступ до значень, які були передані через контекст у вищих компонентах дерева компонентів. Контекст дозволяє передавати дані глибоко в дерево компонентів без необхідності передачі пропсів через проміжні рівні.</br>Приймає один аргумент - обєкт контексту, який був створений за допомогою React.createContext.</br> Він є синхронним, що означає, що буде повернуто значення контексту в основному потоці.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useReducer?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це хук, який дозволяє керувати станом компонента за допомогою функції reducer. </br>Reducer приймає два аргументи:</br> поточний стан і дію(action) і повертає новий стан, а саме два значення.</br> state - поточний стан компонета. </br> dispatch - функція, яка дозволяє виконати дію.</br><pre>dispatch({type: "INCREMENT"})</pre></br>Reducer є чиста функція.</br><pre>const [state, dispatch] = useReducer(reducer, initialState)</pre></br>reducer - це функція редуктора, яка приймає поточний стан і дію, і повертає новий стан.</br>initialState - початковий стан компонента.
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useCallback?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <pre> 
      const memoizedCallback = useCallback(() => {
        console.log("Callback executed!");
      }, []);
    </pre>
    <p>Це хук, який дозволяє кешувати функцію, щоб уникнути повторного створення функції кожного разу, коли компонент рендериться.</br>Приймає два аргументи:</br>функція - яку потрібно кешувати.</br> масив залежностей - динаміні значення, які можуть змінитися і призвести до повторного створення функції.</br>useCallback повертає закешовану функцію та використовується в обробниках подій, де функція може бути викликана неодноразово.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useImperativeHandle?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це хук, який дозволяє налаштовувати значення екземпляра, яке надається батьківським компонентам при використанні ref.
    </br>Приймає три аргументи: </br>імя - це імя екземпляру, яке буде надано батьківським компонентам.(ref)</br> функція - createHandle, функція, що повертає значення, які мають бути відкриті для батьківського компонета.</br>масив залежностей - масив, що визначає, коли має бути оновлений хук.
    <pre>  
      useImperativeHandle(ref, () => ({
      focus: () => {
        inputRef.current.focus();
      },
      getValue: () => {
        return value;
      },
      }));
    </pre>
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useLayoutEffect?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>useLayoutEffect - це хук React, який запускається синхронно до того, як браузер перемальовує екран. Він призначений для обробки побічних ефектів, які вимагають негайних оновлень макета DOM.</br>useLayoutEffect відрізняється від useEffect тим, що він виконується до того, як браузер закінчить обробку всіх DOM-мутацій. Це означає, що будь-які зміни, внесені в DOM в useLayoutEffect, будуть відображені на екрані до того, як браузер почне рендеринг нового стану компоненту.
    </br>useLayoutEffect можна використовувати для виконання таких завдань, як:</br>Вимірювання розмірів DOM-елементів</br>
    Розрахунок позицій DOM-елементів</br>Виконання анімацій або переходів</br>Приймає два аргументи:</br>функція ефекту;</br> масивзалежностей;</p>
    <pre>  
    useLayoutEffect(() => {
    const { height } = ref.current;
    setTooltipHeight(height);
    }, []);
  </pre>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useId?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>useId - це хук React, який генерує унікальні ідентифікатори для компонентів.</br>useId можна використовувати для таких завдань, як:</br>Генерація унікальних ідентифікаторів для елементів форми.</br>Генерація унікальних ідентифікаторів для елементів, які використовуються з анімаціями або переходами. useId Повертає унікальний строковий ідентифікатов.</p>
    <pre>const id = useId();</pre>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке useDefferedValue?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>useDefferedValue - це хук React, який дозволяє відкладати оновлення частини UI. Він приймає на вхід значення, яке буде відкладено до наступного рендерингу компонента.</br>useDefferedValue можна використовувати для таких завдань, як:</br>Завантаження даних з мережі</br>Виконання обчислень, які займають багато часу.</br>Важливо зазначити, що useDefferedValue не впливає на продуктивність компонента.Він просто відкладає оновлення частини UI.</p>
 <pre>  
    useDefferedValue(() => {
      return Math.pow(2, 1000);
    });
  </pre>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Яка різниця між керованими та некерованими компонентами?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Керовані та некеровані компоненти - це два типи компонентів React, які відрізняються тим, як вони керують значеннями своїх елементів форми.</br>Керовані компоненти</br>Керовані компоненти використовують хук useState для зберігання значення своїх елементів форми.</br>Це означає, що React контролює значення цих елементів і оновлює їх при зміні стану компонента.</br>Некеровані компоненти.</br>Некеровані компоненти використовують DOM-рефи для отримання значення своїх елементів форми. </br>Це означає, що компонент сам відповідає за зберігання значення своїх елементів і оновлює їх при необхідності.</br>Різниця між керованими та некерованими компонентами.</br>Основна різниця між керованими та некерованими компонентами полягає в тому, хто відповідає за зберігання значення елементів форми. </br>У керованих компонентах React відповідає за зберігання значення елементів форми. </br>У некерованих компонентах сам компонент відповідає за зберігання значення елементів форми.</br>Керовані компоненти.</br>Переваги:</br>Прості у використанні</br>Легко тестувати</br>Недоліки:</br>Можуть призвести до проблем з продуктивністю, якщо значення елементів форми змінюються часто.</br>Некеровані компоненти.</br>Переваги:</br>Можуть бути більш ефективними, ніж керовані компоненти, якщо значення елементів форми змінюються рідко.</br>Недоліки:</br>Більш складні у використанні</br>Труднощі з тестуванням</br>Коли використовувати керовані компоненти?</br>Керовані компоненти слід використовувати в таких випадках:</br>Коли значення елементів форми змінюються часто</br>Коли необхідно, щоб React керував значенням елементів форми</br>Коли використовувати некеровані компоненти?</br>Некеровані компоненти слід використовувати в таких випадках:</br>Коли значення елементів форми змінюються рідко</br>Коли необхідно, щоб компонент сам відповідав за зберігання значення елементів форми</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке children?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Children - це спеціальний пропс React, який використовується для передачі в компонент даних, які будуть відображені в якості його потомків. Children вказує на елементи, які розміщені між відкриваючим і закриваючим тегом компонента.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке Portals?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Портали в React - це спеціальні компоненти, які дозволяють рендерити дочірні елементи в DOM-вузол, який знаходиться за межами DOM-ієрархії батьківського компонента.</br>Портали можуть бути корисні в таких випадках:</br>Коли необхідно відобразити компонент, який повинен бути видимий поза батьківським компонентом. Наприклад, компонент, який відображає повідомлення про помилку або підказку.</br>Коли необхідно відобразити компонент, який повинен бути видимий в різних точках DOM. Наприклад, компонент, який відображає меню або панель інструментів.</br>Коли необхідно відобразити компонент, який повинен бути видимий в різних вікнах або вкладках.</p>
  <pre>
  function App() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <Portal>
          <div></div>
        </Portal>
      </div>
    );
  }
  </pre>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке Virtual DOM?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Віртуальний DOM (VDOM) - це концепція програмування, в якій ідеальне або «віртуальне» представлення інтерфейсу користувача зберігається в пам'яті і синхронізується з «настоящим» DOM за допомогою бібліотеки, такої як ReactDOM. Цей процес називається узгодженням.</br>VDOM в React використовується для підвищення продуктивності. Він дозволяє React швидко відстежувати зміни в стані компонента і синхронізувати їх з DOM тільки в разі необхідності.</br>VDOM також дозволяє React підтримувати ієрархію DOM. Це означає, що React може відтворювати дерева компонентів, які складаються з інших компонентів.</br>VDOM реалізований в React за допомогою даних про структуру DOM, які називаються «деревом елементів». Дерево елементів - це об'єкт, який представляє структуру DOM у вигляді дерева.</br>React використовує алгоритм узгодження для порівняння дерева елементів з поточним DOM. Якщо дерева не збігаються, React вносить необхідні зміни в DOM.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке JSX?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>JSX - це розширення синтаксису JavaScript, яке дозволяє описувати інтерфейс користувача в стилі HTML. JSX використовується в React для створення компонентів.</br>JSX-код складається з тегів HTML, які можуть містити текст, атрибути і інші JSX-елементи. JSX-код компілюється в звичайний JavaScript, який потім виконується React.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке errorBoundary?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Error Boundary - це класовий компонент React, який відстежує помилки в своїх дочірніх компонентах. Якщо в дочірньому компоненті виникає помилка, Error Boundary відображає запасний UI замість того, щоб показувати білий екран.</br>Error Boundary приймає на вхід один обов'язковий пропс component(компонент, який повинен бути відображений як запасний UI). Цей пропс вказує на компонент, який повинен бути відображений як запасний UI.</br>Використовує метод componentDidCatch(), цей метод викликається, коли в дочірньому компоненті виникає помилка. </br>Метод componentDidCatch() отримує два аргументи: error - інформація про помилку, яка включає стек виклику. errorInfo - інформація про помилку, яка включає стек виклику. Потім огорнути в звичайний компонент <code><ErrorBoundary></ErrorBoundary></code></br>Не працює: з асинхронним кодом, при серверному рендеренгу, в самому Error Boundary</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке key?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Ключ (key) - це спеціальний атрибут, який використовується в React для ідентифікації елементів в списках і масивах.
    </br>Ключі допомагають React відстежувати зміни в списках і масивах і синхронізувати їх з DOM тільки в разі необхідності.</br>
    Ключі повинні бути унікальними для кожного елемента в списку або масиві. Вони можуть бути будь-яким типом даних, який можна використовувати як ідентифікатор, наприклад, число, рядок, об'єкт або функція.</br>
    Якщо ключі не вказані, React буде використовувати індекс елемента в списку або масиві в якості ключа. Це може призвести до проблем з продуктивності, оскільки React буде порівнювати індекси елементів в списку або масиві з минулим станом.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке props, різниця між props і state?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Props (англ. properties, властивості) - це дані, які передаються в компонент як параметри. Props передаються з батьківського компонента до дочірнього.</br>State (англ. state, стан) - це дані, які зберігаються всередині компонента. State може бути змінений компонентом самостійно.</br>Основна різниця між props і state полягає в тому, що props передаються в компонент ззовні, а state зберігається всередині компонента.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке життєві цикли?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>componentDidMount(): Ця подія відбуваєтся після того, як компонент буде монтований в DOM.</br>
      componentDidUpdate(): Ця подія відбуваються після того, як компонент буде оновлений.</br>
      componentWillUnmount(): Ця подія відбуваєтся перед тим, як компонент буде демонтований з DOM.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Різниця між класовими та функціональними компонетами реакт.
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>1. Синтаксис; </br>2. Функціональність - класові мають доступ до цих методів життєвого циклу, а функціональність до деяких. </br>3. Оптимізація - класові компонети можуть бути менш ефективними, ніж функціональні, оскільки вони створюють екземпляр класу при кожному рендерингу. Функціональні є навпаки функціями, які можуть бути повторно використанні без створення нових екземплярів.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке фрагмент?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Фрагмент (англ. Fragment) - це компонент React, який не відображає в DOM жодного елемента. Фрагменти використовуються для об'єднання декількох елементів в один.</br>Фрагменти оголошуються за допомогою тегу <code><React.Fragment></code>. Фрагменти можуть містити будь-який JSX-код, включаючи теги, атрибути, текст і інші фрагменти.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке профайлер?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Профайлер в React - це інструмент, який дозволяє відстежувати продуктивність React-додатків. Профайлер може допомогти вам визначити, які частини вашого додатка займають найбільше часу для рендерингу.</br>Профайлер React доступний у двох варіантах:</br>Стандартний профайлер: Цей профайлер є частиною пакету React. Його можна використовувати для відстеження продуктивності додатка в режимі розробки.</br>Профайлер React DevTools: Цей профайлер є частиною набору інструментів React DevTools. Його можна використовувати для відстеження продуктивності додатка в режимі розробки та в режимі випуску.
    </br>Профайлер React збирає наступні дані про продуктивність:</br>
    Час рендерингу: Час, який потрібен для рендерингу кожного компонента.</br>
    Кількість рендерів: Кількість разів, коли кожен компонент був відрендерован.</br>
    Кількість об'єктів: Кількість об'єктів, створених React.</br>
    Кількість об'єктів, які були видалені.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке узгодження Reconciliation?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Узгодження (англ. reconciliation) - це процес, який React використовує для синхронізації DOM з станом компонентів. Узгодження відбувається кожного разу, коли компонент рендерується або оновлюється.Узгодження складається з наступних етапів:
    </br>Порівняння: React порівнює попередній і новий стан компонента.</br>Ідентифікація змін: React визначає, які елементи в DOM потрібно змінити.</br>Внесення змін: React вносить необхідні зміни в DOM. </br>Для прикладу використовується в віртуальному домі React.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке Synthetic Event?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Synthetic Event - це обгортка навколо нативної події браузера. Вона має той же інтерфейс, що і нативна подія, включаючи методи stopPropagation() та preventDefault() . Ця обгортка допомагає подіям працювати однаково у всіх браузерах.
    </br>Synthetic Event використовується в React для обробки подій. Коли компонент отримує подію, React створює об'єкт Synthetic Event і передає її компоненту. Компонент може використовувати об'єкт Synthetic Event для отримання інформації про подію, наприклад, про тип події, про те, який елемент її викликав і про те, які координати миші або сенсорного екрану були при натисканні.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Тестування в реакт
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Використовують фрейворк Jest або бібліотеку Enzyme.</br> 
    Методи в Jest.</br> 
    test або it - виконується для тестових кейсів.</br> 
    expect - для оголошення очікуваного результату.</br>
    матчери - методи, які використовує expect для порівняння значень.</br>
    beforeEach та afterEach - використовуються для виконання коду.</br>
    beforeAll та afterAll - використовується для виконання до і після усіх тестів.</br>
    describe - групує тести в окремий блок, дозволяючи використовувати beforeEach, afterEach, beforeAll, afterAll.</br>
    to be - метчери для порівняння значень у тестах.</br>
    toThrow - перевірка на викидання винятку.
    </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке lazy?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>В React lazy - це функція, яка повертає Promise, який при вирішенні повертає модуль з default-експортом, який містить React-компонент. Lazy-компоненти можна використовувати для відкладеного завантаження компонентів, які не потрібні користувачеві на початку завантаження сторінки.</br>Lazy-компоненти можна використовувати для відкладеного завантаження таких компонентів:</br>Компоненти, які відображаються тільки в певних умовах, наприклад, тільки якщо користувач ввів певне значення.</br>Компоненти, які є великими або складними, наприклад, компоненти, які відображають велику кількість даних або які використовують багато ресурсів.</br>Компоненти, які є зовнішніми, наприклад, компоненти, які отримані з сторонньої бібліотеки.</br>Щоб використовувати lazy компонент, ви повинні обернути його в компонент Suspense. Компонент Suspense буде відображати заміщаючий вміст, поки компонент не буде завантажено.</br>Fallback використовується з компонентами Suspense, які дозволяють ліниво завантажувати компоненти. Компонент Suspense буде відображати fallback, поки компонент не буде завантажено. Як тільки компонент буде завантажено, він буде відображатись замість fallback.</p>
    <pre>
      const OtherComponent = lazy(() => import('./OtherComponent'));

      const App = () => {
        return (
          <div>
            <Suspense fallback={<div>Завантаження...</div>}>
              <OtherComponent />
            </Suspense>
          </div>
        );
      };

  </pre>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке реакт Fiber?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Fiber -це нова архітектура реакт, яка була введена в React 16. Fiber дозволяє React рендерити інтерфейс користувача більш ефективно та з меншою затримкою.</br>
    Fiber складається з двох фаз:</br>
    Фаза порівнянь</br>
    Фаза рендерингу</br>
    Fiber має кілька переваг перед попередньою архітекторою реакт:</br>
    Покращена продуктивність</br>
    Зменшена затримка</br>
    Більша гнучкість </p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке реакт?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Реакт - це бібліотека для створення інтерфейсів користувача. Реакт використовує декларативний підхід до програмування і базується на компонентах, які є відновлюваними та повторно використовуваними елементами інтерфейсу.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке Pure Component?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це компонет, який завжди рендерить однаковий результат при одних і тих же значеннях пропсів. Маємо огорнути в memo для того, щоб не було лишнього рендерингу.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке ShadowDom?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це технологія, яка дозволяє ізолювати та інкапсолювати частини DOM від решти документа. Зазвичай, коли ви створюєте сторінку веб-сайту, всі стилі та скрипти,які ви використовуєте, мають глобальний доступ до елементів DOM.</br> 
    Shadow DOM вирішує цю проблему, дозволяючи створювати ізольовані компоненти з їх власними стилями та скриптами, які не впливають на решту сторінки</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке умовний рендеринг Conditional Rendering?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Умовний рендеринг - це техніка, яка дозволяє відобразити або приховати елементи користувацького інтерфейсу залежно від значення змінної або виразу.</br> 
    У React умовний рендеринг можна реалізувати за допомогою наступних методів:</br> 
    Умовні оператори: Умовні оператори, такі як if і else, можуть використовуватися для перевірки умови і відображення потрібного фрагмента інтерфейсу користувача.</br> 
    Логічні оператори: Логічні оператори, такі як &&, ||, і !, можуть використовуватися для створення складніших умов.</br> 
    Числа: Значення 0 вважається false, а будь-яке інше значення вважається true.</br> 
    Порожні масиви: Порожній масив вважається false, а будь-який інший масив вважається true.</br> 
    Порожні об'єкти: Порожній об'єкт вважається false, а будь-який інший об'єкт вважається true.</p>
  </div>
</details>
<details style="margin-bottom: 15px;">
  <summary style="cursor: pointer; outline: none; font-weight: bold; font-size: 18px;">
    Що таке Switching Component?
  </summary>
  <div style="padding: 10px; font-size: 16px;">
    <p>Це компонент, який дозволяє відобразити один із кількох компонентів залежно від значення змінної або виразу. Реалізується за допомогою <code>switch</code>.</p>
  </div>
</details>
